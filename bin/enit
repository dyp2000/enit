#!/usr/bin/env escript
%%! -hidden -connect_all false -smp disable -kernel inet_dist_use_interface {127,0,0,1}
-mode(compile).

main([Command | Args]) ->
    application:load(enit),

    %% don't start native dns resolver subprocess
    inet_db:set_lookup([dns]),
    enit_posix:load_nif_or_die(),

    %% ensure epmd is running
    os:cmd("epmd -daemon"),
    run(Command, Args);
main(_) ->
    SN = escript:script_name(),
    io:format("Usage: ~s <command> <args...>~n"
              "~n"
              "Commands:~n"
              "    list              -- list installed releases~n"
              "    startfg <release> -- start a release VM without detaching~n"
              "    stop    <release> -- stop a release VM~n"
              "    status  <release> -- get status information on a release~n~n"
              "Commands for debugging:~n"
              "    remsh   <release> -- open a remote shell into a release~n"
              "    traceip <port>    -- start a TCP trace client (see dbg:trace_client/3)~n"
              "      -h, --host <host> (connect to host instead of localhost)~n"
              "    tracefile <file>  -- read a trace file~n"
              "      -f, --follow (keep reading from file)~n",
              [SN]).

run("startfg", Argv) ->
    cli_command("startfg", Argv, 1, syslog_options());
run("stop", Argv) ->
    cli_command("stop", Argv, 1, syslog_options());
run("remsh", Argv) ->
    cli_command("remsh", Argv, 1, []);
run("traceip", Argv) ->
    cli_command("traceip", Argv, 1, [{option, host, 1, ["-h", "--host"]}]);
run("tracefile", Argv) ->
    cli_command("tracefile", Argv, 1, [{option, follow, 1, ["-f", "--follow"]}]);
run("status", Argv) ->
    cli_command("status", Argv, 1, []);
run("list", Argv) ->
    cli_command("list", Argv, 0, []);
run(_, _) ->
    io:format("Error: unknown command (run with no arguments for help)~n", []),
    erlang:halt(255).

syslog_options() ->
    [{flag, syslog, ["-s", "--syslog"]}].

cli_command(Command, Argv, ArgCount, OptionSpec) ->
    case enit:parse_cmdline(Argv, OptionSpec) of
        {error, Error} ->
            io:format("Error: invalid options: ~s~n", [enit:format_error(Error)]),
            erlang:halt(255);
        {ok, Options, Args} when length(Args) == ArgCount ->
            cli_command1(Command, Args, Options);
        {ok, _Options, _Args} ->
            io:format("Error: invalid number of arguments (command ~s expects ~b)~n", [Command, ArgCount]),
            erlang:halt(255)
    end.

cli_command1(Command, Args, Options) ->
    try apply(enit, list_to_atom("cli_" ++ Command), Args ++ [Options]) of
        {error, Error} ->
            enit_log:error("Error: ~s~n", [enit:format_error(Error)]),
            halt(1);
        _ ->
            halt(0)
    catch
        {error, Error} ->
            enit_log:error("Error: ~s~n", [enit:format_error(Error)]),
            halt(1);
        Class:Other ->
            enit_log:error("enit crashed: ~s:~p~n~p", [Class, Other, erlang:get_stacktrace()]),
            halt(10)
    end.
